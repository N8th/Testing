<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Random Video Clips Compilation - Version 1.0.3</title>
  <style>
    #dropZone {
      width: 100%;
      height: 200px;
      border: 2px dashed #ccc;
      text-align: center;
      line-height: 200px;
      color: #999;
      margin-bottom: 20px;
    }
    video {
      display: none; /* Hide the video element */
    }
    canvas {
      display: block;
      margin-bottom: 10px;
      background-color: black; /* Fill gaps with black */
    }
    .controls {
      margin-bottom: 10px;
    }
    #saveButton {
      display: none;
    }
  </style>
</head>
<body>
  <h1>Upload Videos and Compile Random Clips (Version 1.0.3)</h1>
  
  <!-- Drop zone for files -->
  <div id="dropZone">Drag and drop videos here (up to 50)</div>

  <!-- Min and Max duration controls -->
  <div class="controls">
    <label for="minTime">Min Clip Time (seconds): </label>
    <input type="number" id="minTime" min="1" value="3">
    <label for="maxTime">Max Clip Time (seconds): </label>
    <input type="number" id="maxTime" min="3" value="15">
  </div>
  
  <button id="compileButton" disabled>Compile Random Clips</button>
  <button id="saveButton">Save Compiled Video</button>

  <!-- Hidden video element to load videos -->
  <video id="video" controls></video>

  <!-- Canvas element to display the videos -->
  <canvas id="canvas" width="640" height="360"></canvas>

  <script>
    const dropZone = document.getElementById('dropZone');
    const compileButton = document.getElementById('compileButton');
    const saveButton = document.getElementById('saveButton');
    const videoElement = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const minTimeInput = document.getElementById('minTime');
    const maxTimeInput = document.getElementById('maxTime');

    let videoFiles = [];
    let mediaRecorder;
    let recordedChunks = [];

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, (e) => e.preventDefault());
    });

    // Highlight drop area when item is dragged over
    ['dragenter', 'dragover'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => dropZone.style.borderColor = '#333');
    });

    // Unhighlight drop area when dragging leaves
    ['dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => dropZone.style.borderColor = '#ccc');
    });

    // Handle dropped files
    dropZone.addEventListener('drop', (e) => {
      const files = e.dataTransfer.files;

      for (const file of files) {
        if (file.type.startsWith('video/')) {
          if (videoFiles.length < 50) { // Limit to 50 videos
            videoFiles.push(URL.createObjectURL(file)); // Store video file URLs
          }
        }
      }
      
      if (videoFiles.length > 0) {
        compileButton.disabled = false; // Enable compile button when videos are dropped
        dropZone.textContent = `${videoFiles.length} video(s) ready for compilation.`;
      } else {
        dropZone.textContent = 'Please drop video files!';
      }
    });

    compileButton.addEventListener('click', async function() {
      if (videoFiles.length > 0) {
        compileButton.disabled = true; // Disable button during compilation
        saveButton.style.display = 'none'; // Hide save button initially
        recordedChunks = []; // Clear any previous recordings

        const stream = canvas.captureStream(); // Capture canvas stream for recording
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = function(event) {
          if (event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        };
        mediaRecorder.onstop = saveVideo; // When recording stops, offer save option
        mediaRecorder.start(); // Start recording

        await compileRandomClips();

        mediaRecorder.stop(); // Stop recording once all clips are played
        compileButton.disabled = false; // Re-enable button after compilation
      }
    });

    async function compileRandomClips() {
      let currentIndex = 0;

      const playNextClip = () => {
        if (currentIndex >= videoFiles.length) {
          return; // All clips played
        }

        const videoSrc = videoFiles[currentIndex];
        videoElement.src = videoSrc;

        videoElement.addEventListener('loadedmetadata', () => {
          const videoDuration = videoElement.duration;
          const minTime = parseInt(minTimeInput.value, 10);
          const maxTime = parseInt(maxTimeInput.value, 10);
          
          // Ensure the max time doesn't exceed the video length
          const randomStart = Math.random() * Math.max(0, videoDuration - 1); // Start from random point
          const clipDuration = Math.min(Math.random() * (maxTime - minTime) + minTime, videoDuration - randomStart);

          videoElement.currentTime = randomStart;

          videoElement.play();

          const updateCanvas = () => {
            // Draw the current video frame on the canvas
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            if (!videoElement.paused && !videoElement.ended) {
              requestAnimationFrame(updateCanvas);
            }
          };

          updateCanvas(); // Start drawing frames

          // Play the random clip for its duration
          setTimeout(() => {
            videoElement.pause();
            currentIndex++; // Move to the next video
            playNextClip(); // Play the next clip after the current one ends
          }, clipDuration * 1000);
        }, { once: true });
      };

      playNextClip(); // Start playing the first clip
    }

    function saveVideo() {
      const blob = new Blob(recordedChunks, {
        type: 'video/webm'
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = 'compiled_video.webm';
      document.body.appendChild(a);
      a.click();

      // Make save button available to re-download
      saveButton.style.display = 'block';
    }

    saveButton.addEventListener('click', saveVideo);
  </script>
</body>
</html>